package plugin

import (
	"fmt"
	"maps"
	"os"
	"slices"
	"strings"

	"github.com/go-openapi/inflect"
	orm "github.com/lesomnus/proto-orm"
	"github.com/lesomnus/proto-orm/graph"
	"github.com/lesomnus/proto-orm/pbgen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type Printer struct {
}

func NewPrinter() *Printer {
	return &Printer{}
}

func (*Printer) Print(f *File) error {
	if len(f.Entities) == 0 {
		return os.ErrNotExist
	}

	f.P(`// Code generated by "proto-orm-gen-ent". DO NOT EDIT`)
	f.P("")

	pf := &pbgen.ProtoFile{
		Edition: pbgen.SyntaxProto3,
		Imports: []pbgen.Import{
			{Name: f.Entities[0].File.Desc.Path()},
		},
	}
	if d := f.Source().Proto; d != nil {
		pf.Package = protoreflect.FullName(*d.Package)
		for _, s := range d.Dependency {
			if s == "orm.proto" {
				continue
			}
			pf.AddImport(pbgen.Import{Name: s})
		}
		pf.Options = []pbgen.Option{
			pbgen.OptionGoPackage(*d.Options.GoPackage),
		}
	}

	w := printWork{
		file:     pf,
		services: map[protoreflect.FullName]*pbgen.Service{},
		messages: map[protoreflect.FullName]*pbgen.Message{},
	}
	for _, e := range f.Entities {
		o := orm.ResolveRpcOptions(f.Source(), e.Source)
		if o == nil {
			continue
		}

		w.Do(e, o)
	}

	ss := slices.Collect(maps.Values(w.services))
	slices.SortFunc(ss, func(a *pbgen.Service, b *pbgen.Service) int {
		return strings.Compare(string(a.Name), string(b.Name))
	})

	for _, v := range w.services {
		pf.TopLevelDefinitions = append(pf.TopLevelDefinitions, v)
	}

	// Processed message.
	ms := map[pbgen.Type]bool{}
	for _, s := range ss {
		for _, e := range s.Body {
			r, ok := e.(pbgen.Rpc)
			if !ok {
				continue
			}
			if _, ok := ms[r.Request.Type]; ok {
				continue
			} else {
				ms[r.Request.Type] = true
			}

			m, ok := w.messages[protoreflect.FullName(r.Request.Type)]
			if !ok {
				panic(fmt.Sprintf("message must be exist: %s", r.Request.Type))
			}

			pf.TopLevelDefinitions = append(pf.TopLevelDefinitions, m)

			// Note that messages for response are defined in the another files:
			// e.g. entity messages, well known messages.
		}
	}
	return pbgen.Execute(f, pf)
}

type printWork struct {
	file     *pbgen.ProtoFile
	services map[protoreflect.FullName]*pbgen.Service
	messages map[protoreflect.FullName]*pbgen.Message
}

func (w *printWork) rpc(r *graph.Rpc) pbgen.Rpc {
	return pbgen.Rpc{
		Name: protoreflect.Name(r.Name),
		Request: pbgen.RpcType{
			Type: pbgen.Type(r.Req.FullName),
		},
		Response: pbgen.RpcType{
			Type: pbgen.Type(r.Res.FullName),
		},
	}
}

func (w *printWork) Do(e *graph.Entity, o *orm.RpcOptions) {
	s := &pbgen.Service{
		Name: protoreflect.Name(fmt.Sprintf("%sService", e.Name())),
	}
	if o.Add != nil && !o.Add.Disabled {
		r := e.Rpcs[graph.RpcOpAdd]
		s.Body = append(s.Body, w.rpcAdd(r))
	}
	if o.Get != nil && !o.Get.Disabled {
		r := e.Rpcs[graph.RpcOpGet]
		s.Body = append(s.Body, w.rpcGet(r))
	}
	// if o.List != nil && !o.List.Disabled {
	// }
	if o.Patch != nil && !o.Patch.Disabled {
		r := e.Rpcs[graph.RpcOpPatch]
		s.Body = append(s.Body, w.rpcPatch(r))
	}
	if o.Erase != nil && !o.Erase.Disabled {
		r := e.Rpcs[graph.RpcOpErase]
		s.Body = append(s.Body, w.rpcErase(r))
	}

	w.services[e.FullName()] = s
}

func (w *printWork) msgAddReq(r *graph.Rpc) *pbgen.Message {
	full := r.Req.FullName
	if m, ok := w.messages[full]; ok {
		return m
	}

	m := &pbgen.Message{Name: full.Name()}
	w.messages[full] = m

	body := []pbgen.MessageBody{}
	for _, f := range r.Entity.FieldsSortByNumber() {
		d := f.Desc
		v := pbgen.MessageField{
			Name:   d.Name(),
			Number: int(d.Number()),
		}
		if f.IsBound() {
			// Skip since edge field (which accessed by `f.Bound`) will be added.
			continue
		} else if f.Message == nil {
			// Field is scalar.
			// e.g. string, int32, ...
			v.Type = pbgen.Type(d.Kind().String())
		} else if !f.IsEdge() {
			// Field is not scalar but is well known type that can be mapped to scalar.
			// e.g. google.protobuf.Timestamp -> time.Time
			v.Type = pbgen.Type(f.Message.Desc.FullName())
		} else {
			target := f.Edge.Target
			r := target.Rpcs[graph.RpcOpGet]
			if r == nil {
				panic("TODO: target entity does not enables Get rpc")
				// To resolve this, graph should parse disabled rpcs also
				// or make one lazily.
			}
			m := w.msgGetReq(r)
			n := target.FullName().Parent().Append(m.Name)
			v.Type = pbgen.Type(n)
		}
		if f.IsList() {
			v.Label = pbgen.LabelRepeated
		} else if !f.Required {
			v.Label = pbgen.LabelOptional
		}

		body = append(body, v)
	}

	m.Body = body
	return m
}

func (w *printWork) rpcAdd(r *graph.Rpc) pbgen.Rpc {
	w.msgAddReq(r)
	return w.rpc(r)
}

func (w *printWork) nameIndexGet(e *graph.Entity, i *graph.Index) protoreflect.FullName {
	n := fmt.Sprintf("%sGetRequestBy%s", inflect.Camelize(e.Name()), inflect.Camelize(i.Name()))
	return e.FullName().Parent().Append(protoreflect.Name(n))
}

func (w *printWork) indexGet(e *graph.Entity, i *graph.Index) *pbgen.Message {
	full := w.nameIndexGet(e, i)
	if m, ok := w.messages[full]; ok {
		return m
	}

	m := &pbgen.Message{Name: full.Name()}
	w.messages[full] = m

	body := []pbgen.MessageBody{}
	for _, r := range i.Refs {
		d := r.Desc
		if r.IsEdge() {
			target := r.Edge.Target
			m := w.msgGetReq(target.Rpcs[graph.RpcOpGet])
			n := target.FullName().Parent().Append(m.Name)
			v := pbgen.MessageField{
				Type:   pbgen.Type(n),
				Name:   protoreflect.Name(d.Name()),
				Number: int(d.Number()),
			}
			body = append(body, v)
		} else {
			body = append(body, pbgen.MessageField{
				Name:   d.Name(),
				Type:   pbgen.Type(d.Kind().String()),
				Number: int(d.Number()),
			})
		}
	}

	m.Body = body
	return m
}

func (w *printWork) msgGetReq(r *graph.Rpc) *pbgen.Message {
	full := r.Req.FullName
	if m, ok := w.messages[full]; ok {
		return m
	}

	m := &pbgen.Message{Name: full.Name()}
	w.messages[full] = m

	oneof := pbgen.MessageOneof{Name: "key"}
	for _, f := range r.Entity.FieldsSortByNumber() {
		if !f.Unique {
			continue
		}
		if f.IsEdge() {
			continue
		}

		d := f.Desc
		oneof.Body = append(oneof.Body, pbgen.MessageOneofField{
			Type:   pbgen.Type(d.Kind().String()),
			Name:   d.Name(),
			Number: int(d.Number()),
		})
	}
	for _, i := range r.Entity.Indexes {
		if !i.Unique {
			continue
		}

		m := w.indexGet(r.Entity, i)
		oneof.Body = append(oneof.Body, pbgen.MessageOneofField{
			Type:   pbgen.Type(m.Name),
			Name:   protoreflect.Name(i.Name()),
			Number: int(i.Refs[0].Desc.Number()),
		})
	}

	m.Body = []pbgen.MessageBody{oneof}
	return m
}

func (w *printWork) rpcGet(r *graph.Rpc) pbgen.Rpc {
	w.msgGetReq(r)
	return w.rpc(r)
}

func (w *printWork) msgPatchReq(r *graph.Rpc) *pbgen.Message {
	full := r.Req.FullName
	if m, ok := w.messages[full]; ok {
		return m
	}

	m := &pbgen.Message{Name: full.Name()}
	w.messages[full] = m

	k := w.msgGetReq(r.Entity.Rpcs[graph.RpcOpGet])
	k_f := k.Body[0].(pbgen.MessageOneof).Body[0].(pbgen.MessageOneofField)
	body := []pbgen.MessageBody{pbgen.MessageField{
		Type:   pbgen.Type(k.Name),
		Name:   "key",
		Number: k_f.Number*2 - 1,
	}}

	for _, f := range r.Entity.FieldsSortByNumber() {
		if f.Immutable {
			// Key must be immutable
			continue
		}

		d := f.Desc
		n := int(d.Number())*2 - 1
		if n == body[0].(pbgen.MessageField).Number {
			continue
		}

		v := pbgen.MessageField{
			Name:   d.Name(),
			Number: n,
		}
		if f.Message == nil {
			v.Type = pbgen.Type(d.Kind().String())
		} else {
			v.Type = pbgen.Type(f.Message.Desc.FullName())
		}
		if f.IsList() {
			v.Label = pbgen.LabelRepeated
		} else {
			v.Label = pbgen.LabelOptional
		}

		body = append(body, v)
		if f.Nullable {
			body = append(body, pbgen.MessageField{
				Type:   pbgen.TypeBool,
				Name:   protoreflect.Name(fmt.Sprintf("%s_null", d.Name())),
				Number: int(d.Number()) * 2,
			})
		}
	}

	m.Body = body
	return m
}

func (w *printWork) rpcPatch(r *graph.Rpc) pbgen.Rpc {
	w.msgPatchReq(r)
	w.file.AddImport(pbgen.Import{
		Name: pbgen.ImportWellKnownEmpty,
	})
	return w.rpc(r)
}

func (w *printWork) rpcErase(r *graph.Rpc) pbgen.Rpc {
	w.msgGetReq(r)
	w.file.AddImport(pbgen.Import{
		Name: pbgen.ImportWellKnownEmpty,
	})
	return w.rpc(r)
}
