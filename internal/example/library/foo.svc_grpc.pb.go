// Code generated by "proto-orm-gen-ent". DO NOT EDIT

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0
// source: example/library/foo.svc.proto

package library

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FooEfService_Add_FullMethodName   = "/example.library.FooEfService/Add"
	FooEfService_Get_FullMethodName   = "/example.library.FooEfService/Get"
	FooEfService_Patch_FullMethodName = "/example.library.FooEfService/Patch"
	FooEfService_Erase_FullMethodName = "/example.library.FooEfService/Erase"
)

// FooEfServiceClient is the client API for FooEfService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooEfServiceClient interface {
	Add(ctx context.Context, in *FooEfAddRequest, opts ...grpc.CallOption) (*FooEf, error)
	Get(ctx context.Context, in *FooEfGetRequest, opts ...grpc.CallOption) (*FooEf, error)
	Patch(ctx context.Context, in *FooEfPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooEfGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooEfServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooEfServiceClient(cc grpc.ClientConnInterface) FooEfServiceClient {
	return &fooEfServiceClient{cc}
}

func (c *fooEfServiceClient) Add(ctx context.Context, in *FooEfAddRequest, opts ...grpc.CallOption) (*FooEf, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooEf)
	err := c.cc.Invoke(ctx, FooEfService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooEfServiceClient) Get(ctx context.Context, in *FooEfGetRequest, opts ...grpc.CallOption) (*FooEf, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooEf)
	err := c.cc.Invoke(ctx, FooEfService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooEfServiceClient) Patch(ctx context.Context, in *FooEfPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooEfService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooEfServiceClient) Erase(ctx context.Context, in *FooEfGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooEfService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooEfServiceServer is the server API for FooEfService service.
// All implementations must embed UnimplementedFooEfServiceServer
// for forward compatibility.
type FooEfServiceServer interface {
	Add(context.Context, *FooEfAddRequest) (*FooEf, error)
	Get(context.Context, *FooEfGetRequest) (*FooEf, error)
	Patch(context.Context, *FooEfPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooEfGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooEfServiceServer()
}

// UnimplementedFooEfServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooEfServiceServer struct{}

func (UnimplementedFooEfServiceServer) Add(context.Context, *FooEfAddRequest) (*FooEf, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooEfServiceServer) Get(context.Context, *FooEfGetRequest) (*FooEf, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooEfServiceServer) Patch(context.Context, *FooEfPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooEfServiceServer) Erase(context.Context, *FooEfGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooEfServiceServer) mustEmbedUnimplementedFooEfServiceServer() {}
func (UnimplementedFooEfServiceServer) testEmbeddedByValue()                      {}

// UnsafeFooEfServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooEfServiceServer will
// result in compilation errors.
type UnsafeFooEfServiceServer interface {
	mustEmbedUnimplementedFooEfServiceServer()
}

func RegisterFooEfServiceServer(s grpc.ServiceRegistrar, srv FooEfServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooEfServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooEfService_ServiceDesc, srv)
}

func _FooEfService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooEfAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooEfServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooEfService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooEfServiceServer).Add(ctx, req.(*FooEfAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooEfService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooEfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooEfServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooEfService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooEfServiceServer).Get(ctx, req.(*FooEfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooEfService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooEfPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooEfServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooEfService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooEfServiceServer).Patch(ctx, req.(*FooEfPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooEfService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooEfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooEfServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooEfService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooEfServiceServer).Erase(ctx, req.(*FooEfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooEfService_ServiceDesc is the grpc.ServiceDesc for FooEfService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooEfService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooEfService",
	HandlerType: (*FooEfServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooEfService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooEfService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooEfService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooEfService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooKService_Add_FullMethodName   = "/example.library.FooKService/Add"
	FooKService_Get_FullMethodName   = "/example.library.FooKService/Get"
	FooKService_Patch_FullMethodName = "/example.library.FooKService/Patch"
	FooKService_Erase_FullMethodName = "/example.library.FooKService/Erase"
)

// FooKServiceClient is the client API for FooKService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooKServiceClient interface {
	Add(ctx context.Context, in *FooKAddRequest, opts ...grpc.CallOption) (*FooK, error)
	Get(ctx context.Context, in *FooKGetRequest, opts ...grpc.CallOption) (*FooK, error)
	Patch(ctx context.Context, in *FooKPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooKGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooKServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooKServiceClient(cc grpc.ClientConnInterface) FooKServiceClient {
	return &fooKServiceClient{cc}
}

func (c *fooKServiceClient) Add(ctx context.Context, in *FooKAddRequest, opts ...grpc.CallOption) (*FooK, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooK)
	err := c.cc.Invoke(ctx, FooKService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooKServiceClient) Get(ctx context.Context, in *FooKGetRequest, opts ...grpc.CallOption) (*FooK, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooK)
	err := c.cc.Invoke(ctx, FooKService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooKServiceClient) Patch(ctx context.Context, in *FooKPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooKService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooKServiceClient) Erase(ctx context.Context, in *FooKGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooKService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooKServiceServer is the server API for FooKService service.
// All implementations must embed UnimplementedFooKServiceServer
// for forward compatibility.
type FooKServiceServer interface {
	Add(context.Context, *FooKAddRequest) (*FooK, error)
	Get(context.Context, *FooKGetRequest) (*FooK, error)
	Patch(context.Context, *FooKPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooKGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooKServiceServer()
}

// UnimplementedFooKServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooKServiceServer struct{}

func (UnimplementedFooKServiceServer) Add(context.Context, *FooKAddRequest) (*FooK, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooKServiceServer) Get(context.Context, *FooKGetRequest) (*FooK, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooKServiceServer) Patch(context.Context, *FooKPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooKServiceServer) Erase(context.Context, *FooKGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooKServiceServer) mustEmbedUnimplementedFooKServiceServer() {}
func (UnimplementedFooKServiceServer) testEmbeddedByValue()                     {}

// UnsafeFooKServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooKServiceServer will
// result in compilation errors.
type UnsafeFooKServiceServer interface {
	mustEmbedUnimplementedFooKServiceServer()
}

func RegisterFooKServiceServer(s grpc.ServiceRegistrar, srv FooKServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooKServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooKService_ServiceDesc, srv)
}

func _FooKService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooKAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooKServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooKService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooKServiceServer).Add(ctx, req.(*FooKAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooKService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooKGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooKServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooKService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooKServiceServer).Get(ctx, req.(*FooKGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooKService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooKPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooKServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooKService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooKServiceServer).Patch(ctx, req.(*FooKPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooKService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooKGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooKServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooKService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooKServiceServer).Erase(ctx, req.(*FooKGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooKService_ServiceDesc is the grpc.ServiceDesc for FooKService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooKService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooKService",
	HandlerType: (*FooKServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooKService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooKService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooKService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooKService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooMiService_Add_FullMethodName   = "/example.library.FooMiService/Add"
	FooMiService_Get_FullMethodName   = "/example.library.FooMiService/Get"
	FooMiService_Patch_FullMethodName = "/example.library.FooMiService/Patch"
	FooMiService_Erase_FullMethodName = "/example.library.FooMiService/Erase"
)

// FooMiServiceClient is the client API for FooMiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooMiServiceClient interface {
	Add(ctx context.Context, in *FooMiAddRequest, opts ...grpc.CallOption) (*FooMi, error)
	Get(ctx context.Context, in *FooMiGetRequest, opts ...grpc.CallOption) (*FooMi, error)
	Patch(ctx context.Context, in *FooMiPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooMiGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooMiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooMiServiceClient(cc grpc.ClientConnInterface) FooMiServiceClient {
	return &fooMiServiceClient{cc}
}

func (c *fooMiServiceClient) Add(ctx context.Context, in *FooMiAddRequest, opts ...grpc.CallOption) (*FooMi, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooMi)
	err := c.cc.Invoke(ctx, FooMiService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMiServiceClient) Get(ctx context.Context, in *FooMiGetRequest, opts ...grpc.CallOption) (*FooMi, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooMi)
	err := c.cc.Invoke(ctx, FooMiService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMiServiceClient) Patch(ctx context.Context, in *FooMiPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooMiService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMiServiceClient) Erase(ctx context.Context, in *FooMiGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooMiService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooMiServiceServer is the server API for FooMiService service.
// All implementations must embed UnimplementedFooMiServiceServer
// for forward compatibility.
type FooMiServiceServer interface {
	Add(context.Context, *FooMiAddRequest) (*FooMi, error)
	Get(context.Context, *FooMiGetRequest) (*FooMi, error)
	Patch(context.Context, *FooMiPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooMiGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooMiServiceServer()
}

// UnimplementedFooMiServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooMiServiceServer struct{}

func (UnimplementedFooMiServiceServer) Add(context.Context, *FooMiAddRequest) (*FooMi, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooMiServiceServer) Get(context.Context, *FooMiGetRequest) (*FooMi, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooMiServiceServer) Patch(context.Context, *FooMiPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooMiServiceServer) Erase(context.Context, *FooMiGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooMiServiceServer) mustEmbedUnimplementedFooMiServiceServer() {}
func (UnimplementedFooMiServiceServer) testEmbeddedByValue()                      {}

// UnsafeFooMiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooMiServiceServer will
// result in compilation errors.
type UnsafeFooMiServiceServer interface {
	mustEmbedUnimplementedFooMiServiceServer()
}

func RegisterFooMiServiceServer(s grpc.ServiceRegistrar, srv FooMiServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooMiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooMiService_ServiceDesc, srv)
}

func _FooMiService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMiAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMiServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMiService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMiServiceServer).Add(ctx, req.(*FooMiAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMiService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMiGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMiServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMiService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMiServiceServer).Get(ctx, req.(*FooMiGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMiService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMiPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMiServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMiService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMiServiceServer).Patch(ctx, req.(*FooMiPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMiService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMiGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMiServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMiService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMiServiceServer).Erase(ctx, req.(*FooMiGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooMiService_ServiceDesc is the grpc.ServiceDesc for FooMiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooMiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooMiService",
	HandlerType: (*FooMiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooMiService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooMiService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooMiService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooMiService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooMsService_Add_FullMethodName   = "/example.library.FooMsService/Add"
	FooMsService_Get_FullMethodName   = "/example.library.FooMsService/Get"
	FooMsService_Patch_FullMethodName = "/example.library.FooMsService/Patch"
	FooMsService_Erase_FullMethodName = "/example.library.FooMsService/Erase"
)

// FooMsServiceClient is the client API for FooMsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooMsServiceClient interface {
	Add(ctx context.Context, in *FooMsAddRequest, opts ...grpc.CallOption) (*FooMs, error)
	Get(ctx context.Context, in *FooMsGetRequest, opts ...grpc.CallOption) (*FooMs, error)
	Patch(ctx context.Context, in *FooMsPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooMsGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooMsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooMsServiceClient(cc grpc.ClientConnInterface) FooMsServiceClient {
	return &fooMsServiceClient{cc}
}

func (c *fooMsServiceClient) Add(ctx context.Context, in *FooMsAddRequest, opts ...grpc.CallOption) (*FooMs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooMs)
	err := c.cc.Invoke(ctx, FooMsService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMsServiceClient) Get(ctx context.Context, in *FooMsGetRequest, opts ...grpc.CallOption) (*FooMs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooMs)
	err := c.cc.Invoke(ctx, FooMsService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMsServiceClient) Patch(ctx context.Context, in *FooMsPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooMsService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMsServiceClient) Erase(ctx context.Context, in *FooMsGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooMsService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooMsServiceServer is the server API for FooMsService service.
// All implementations must embed UnimplementedFooMsServiceServer
// for forward compatibility.
type FooMsServiceServer interface {
	Add(context.Context, *FooMsAddRequest) (*FooMs, error)
	Get(context.Context, *FooMsGetRequest) (*FooMs, error)
	Patch(context.Context, *FooMsPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooMsGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooMsServiceServer()
}

// UnimplementedFooMsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooMsServiceServer struct{}

func (UnimplementedFooMsServiceServer) Add(context.Context, *FooMsAddRequest) (*FooMs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooMsServiceServer) Get(context.Context, *FooMsGetRequest) (*FooMs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooMsServiceServer) Patch(context.Context, *FooMsPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooMsServiceServer) Erase(context.Context, *FooMsGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooMsServiceServer) mustEmbedUnimplementedFooMsServiceServer() {}
func (UnimplementedFooMsServiceServer) testEmbeddedByValue()                      {}

// UnsafeFooMsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooMsServiceServer will
// result in compilation errors.
type UnsafeFooMsServiceServer interface {
	mustEmbedUnimplementedFooMsServiceServer()
}

func RegisterFooMsServiceServer(s grpc.ServiceRegistrar, srv FooMsServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooMsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooMsService_ServiceDesc, srv)
}

func _FooMsService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMsAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMsServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMsService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMsServiceServer).Add(ctx, req.(*FooMsAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMsGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMsServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMsService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMsServiceServer).Get(ctx, req.(*FooMsGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMsService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMsPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMsServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMsService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMsServiceServer).Patch(ctx, req.(*FooMsPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMsService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMsGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMsServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMsService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMsServiceServer).Erase(ctx, req.(*FooMsGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooMsService_ServiceDesc is the grpc.ServiceDesc for FooMsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooMsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooMsService",
	HandlerType: (*FooMsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooMsService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooMsService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooMsService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooMsService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooMsdService_Add_FullMethodName   = "/example.library.FooMsdService/Add"
	FooMsdService_Get_FullMethodName   = "/example.library.FooMsdService/Get"
	FooMsdService_Patch_FullMethodName = "/example.library.FooMsdService/Patch"
	FooMsdService_Erase_FullMethodName = "/example.library.FooMsdService/Erase"
)

// FooMsdServiceClient is the client API for FooMsdService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooMsdServiceClient interface {
	Add(ctx context.Context, in *FooMsdAddRequest, opts ...grpc.CallOption) (*FooMsd, error)
	Get(ctx context.Context, in *FooMsdGetRequest, opts ...grpc.CallOption) (*FooMsd, error)
	Patch(ctx context.Context, in *FooMsdPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooMsdGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooMsdServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooMsdServiceClient(cc grpc.ClientConnInterface) FooMsdServiceClient {
	return &fooMsdServiceClient{cc}
}

func (c *fooMsdServiceClient) Add(ctx context.Context, in *FooMsdAddRequest, opts ...grpc.CallOption) (*FooMsd, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooMsd)
	err := c.cc.Invoke(ctx, FooMsdService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMsdServiceClient) Get(ctx context.Context, in *FooMsdGetRequest, opts ...grpc.CallOption) (*FooMsd, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooMsd)
	err := c.cc.Invoke(ctx, FooMsdService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMsdServiceClient) Patch(ctx context.Context, in *FooMsdPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooMsdService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooMsdServiceClient) Erase(ctx context.Context, in *FooMsdGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooMsdService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooMsdServiceServer is the server API for FooMsdService service.
// All implementations must embed UnimplementedFooMsdServiceServer
// for forward compatibility.
type FooMsdServiceServer interface {
	Add(context.Context, *FooMsdAddRequest) (*FooMsd, error)
	Get(context.Context, *FooMsdGetRequest) (*FooMsd, error)
	Patch(context.Context, *FooMsdPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooMsdGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooMsdServiceServer()
}

// UnimplementedFooMsdServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooMsdServiceServer struct{}

func (UnimplementedFooMsdServiceServer) Add(context.Context, *FooMsdAddRequest) (*FooMsd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooMsdServiceServer) Get(context.Context, *FooMsdGetRequest) (*FooMsd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooMsdServiceServer) Patch(context.Context, *FooMsdPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooMsdServiceServer) Erase(context.Context, *FooMsdGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooMsdServiceServer) mustEmbedUnimplementedFooMsdServiceServer() {}
func (UnimplementedFooMsdServiceServer) testEmbeddedByValue()                       {}

// UnsafeFooMsdServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooMsdServiceServer will
// result in compilation errors.
type UnsafeFooMsdServiceServer interface {
	mustEmbedUnimplementedFooMsdServiceServer()
}

func RegisterFooMsdServiceServer(s grpc.ServiceRegistrar, srv FooMsdServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooMsdServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooMsdService_ServiceDesc, srv)
}

func _FooMsdService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMsdAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMsdServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMsdService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMsdServiceServer).Add(ctx, req.(*FooMsdAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMsdService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMsdGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMsdServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMsdService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMsdServiceServer).Get(ctx, req.(*FooMsdGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMsdService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMsdPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMsdServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMsdService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMsdServiceServer).Patch(ctx, req.(*FooMsdPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooMsdService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooMsdGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooMsdServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooMsdService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooMsdServiceServer).Erase(ctx, req.(*FooMsdGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooMsdService_ServiceDesc is the grpc.ServiceDesc for FooMsdService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooMsdService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooMsdService",
	HandlerType: (*FooMsdServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooMsdService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooMsdService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooMsdService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooMsdService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooVService_Add_FullMethodName   = "/example.library.FooVService/Add"
	FooVService_Get_FullMethodName   = "/example.library.FooVService/Get"
	FooVService_Patch_FullMethodName = "/example.library.FooVService/Patch"
	FooVService_Erase_FullMethodName = "/example.library.FooVService/Erase"
)

// FooVServiceClient is the client API for FooVService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooVServiceClient interface {
	Add(ctx context.Context, in *FooVAddRequest, opts ...grpc.CallOption) (*FooV, error)
	Get(ctx context.Context, in *FooVGetRequest, opts ...grpc.CallOption) (*FooV, error)
	Patch(ctx context.Context, in *FooVPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooVGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooVServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooVServiceClient(cc grpc.ClientConnInterface) FooVServiceClient {
	return &fooVServiceClient{cc}
}

func (c *fooVServiceClient) Add(ctx context.Context, in *FooVAddRequest, opts ...grpc.CallOption) (*FooV, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooV)
	err := c.cc.Invoke(ctx, FooVService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVServiceClient) Get(ctx context.Context, in *FooVGetRequest, opts ...grpc.CallOption) (*FooV, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooV)
	err := c.cc.Invoke(ctx, FooVService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVServiceClient) Patch(ctx context.Context, in *FooVPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVServiceClient) Erase(ctx context.Context, in *FooVGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooVServiceServer is the server API for FooVService service.
// All implementations must embed UnimplementedFooVServiceServer
// for forward compatibility.
type FooVServiceServer interface {
	Add(context.Context, *FooVAddRequest) (*FooV, error)
	Get(context.Context, *FooVGetRequest) (*FooV, error)
	Patch(context.Context, *FooVPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooVGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooVServiceServer()
}

// UnimplementedFooVServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooVServiceServer struct{}

func (UnimplementedFooVServiceServer) Add(context.Context, *FooVAddRequest) (*FooV, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooVServiceServer) Get(context.Context, *FooVGetRequest) (*FooV, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooVServiceServer) Patch(context.Context, *FooVPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooVServiceServer) Erase(context.Context, *FooVGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooVServiceServer) mustEmbedUnimplementedFooVServiceServer() {}
func (UnimplementedFooVServiceServer) testEmbeddedByValue()                     {}

// UnsafeFooVServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooVServiceServer will
// result in compilation errors.
type UnsafeFooVServiceServer interface {
	mustEmbedUnimplementedFooVServiceServer()
}

func RegisterFooVServiceServer(s grpc.ServiceRegistrar, srv FooVServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooVServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooVService_ServiceDesc, srv)
}

func _FooVService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVServiceServer).Add(ctx, req.(*FooVAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVServiceServer).Get(ctx, req.(*FooVGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVServiceServer).Patch(ctx, req.(*FooVPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVServiceServer).Erase(ctx, req.(*FooVGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooVService_ServiceDesc is the grpc.ServiceDesc for FooVService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooVService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooVService",
	HandlerType: (*FooVServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooVService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooVService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooVService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooVService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooVdService_Add_FullMethodName   = "/example.library.FooVdService/Add"
	FooVdService_Get_FullMethodName   = "/example.library.FooVdService/Get"
	FooVdService_Patch_FullMethodName = "/example.library.FooVdService/Patch"
	FooVdService_Erase_FullMethodName = "/example.library.FooVdService/Erase"
)

// FooVdServiceClient is the client API for FooVdService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooVdServiceClient interface {
	Add(ctx context.Context, in *FooVdAddRequest, opts ...grpc.CallOption) (*FooVd, error)
	Get(ctx context.Context, in *FooVdGetRequest, opts ...grpc.CallOption) (*FooVd, error)
	Patch(ctx context.Context, in *FooVdPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooVdGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooVdServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooVdServiceClient(cc grpc.ClientConnInterface) FooVdServiceClient {
	return &fooVdServiceClient{cc}
}

func (c *fooVdServiceClient) Add(ctx context.Context, in *FooVdAddRequest, opts ...grpc.CallOption) (*FooVd, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooVd)
	err := c.cc.Invoke(ctx, FooVdService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVdServiceClient) Get(ctx context.Context, in *FooVdGetRequest, opts ...grpc.CallOption) (*FooVd, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooVd)
	err := c.cc.Invoke(ctx, FooVdService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVdServiceClient) Patch(ctx context.Context, in *FooVdPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVdService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVdServiceClient) Erase(ctx context.Context, in *FooVdGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVdService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooVdServiceServer is the server API for FooVdService service.
// All implementations must embed UnimplementedFooVdServiceServer
// for forward compatibility.
type FooVdServiceServer interface {
	Add(context.Context, *FooVdAddRequest) (*FooVd, error)
	Get(context.Context, *FooVdGetRequest) (*FooVd, error)
	Patch(context.Context, *FooVdPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooVdGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooVdServiceServer()
}

// UnimplementedFooVdServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooVdServiceServer struct{}

func (UnimplementedFooVdServiceServer) Add(context.Context, *FooVdAddRequest) (*FooVd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooVdServiceServer) Get(context.Context, *FooVdGetRequest) (*FooVd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooVdServiceServer) Patch(context.Context, *FooVdPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooVdServiceServer) Erase(context.Context, *FooVdGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooVdServiceServer) mustEmbedUnimplementedFooVdServiceServer() {}
func (UnimplementedFooVdServiceServer) testEmbeddedByValue()                      {}

// UnsafeFooVdServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooVdServiceServer will
// result in compilation errors.
type UnsafeFooVdServiceServer interface {
	mustEmbedUnimplementedFooVdServiceServer()
}

func RegisterFooVdServiceServer(s grpc.ServiceRegistrar, srv FooVdServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooVdServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooVdService_ServiceDesc, srv)
}

func _FooVdService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVdAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVdServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVdService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVdServiceServer).Add(ctx, req.(*FooVdAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVdService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVdGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVdServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVdService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVdServiceServer).Get(ctx, req.(*FooVdGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVdService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVdPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVdServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVdService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVdServiceServer).Patch(ctx, req.(*FooVdPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVdService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVdGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVdServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVdService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVdServiceServer).Erase(ctx, req.(*FooVdGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooVdService_ServiceDesc is the grpc.ServiceDesc for FooVdService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooVdService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooVdService",
	HandlerType: (*FooVdServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooVdService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooVdService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooVdService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooVdService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooVoService_Add_FullMethodName   = "/example.library.FooVoService/Add"
	FooVoService_Get_FullMethodName   = "/example.library.FooVoService/Get"
	FooVoService_Patch_FullMethodName = "/example.library.FooVoService/Patch"
	FooVoService_Erase_FullMethodName = "/example.library.FooVoService/Erase"
)

// FooVoServiceClient is the client API for FooVoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooVoServiceClient interface {
	Add(ctx context.Context, in *FooVoAddRequest, opts ...grpc.CallOption) (*FooVo, error)
	Get(ctx context.Context, in *FooVoGetRequest, opts ...grpc.CallOption) (*FooVo, error)
	Patch(ctx context.Context, in *FooVoPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooVoGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooVoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooVoServiceClient(cc grpc.ClientConnInterface) FooVoServiceClient {
	return &fooVoServiceClient{cc}
}

func (c *fooVoServiceClient) Add(ctx context.Context, in *FooVoAddRequest, opts ...grpc.CallOption) (*FooVo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooVo)
	err := c.cc.Invoke(ctx, FooVoService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVoServiceClient) Get(ctx context.Context, in *FooVoGetRequest, opts ...grpc.CallOption) (*FooVo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooVo)
	err := c.cc.Invoke(ctx, FooVoService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVoServiceClient) Patch(ctx context.Context, in *FooVoPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVoService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVoServiceClient) Erase(ctx context.Context, in *FooVoGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVoService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooVoServiceServer is the server API for FooVoService service.
// All implementations must embed UnimplementedFooVoServiceServer
// for forward compatibility.
type FooVoServiceServer interface {
	Add(context.Context, *FooVoAddRequest) (*FooVo, error)
	Get(context.Context, *FooVoGetRequest) (*FooVo, error)
	Patch(context.Context, *FooVoPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooVoGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooVoServiceServer()
}

// UnimplementedFooVoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooVoServiceServer struct{}

func (UnimplementedFooVoServiceServer) Add(context.Context, *FooVoAddRequest) (*FooVo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooVoServiceServer) Get(context.Context, *FooVoGetRequest) (*FooVo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooVoServiceServer) Patch(context.Context, *FooVoPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooVoServiceServer) Erase(context.Context, *FooVoGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooVoServiceServer) mustEmbedUnimplementedFooVoServiceServer() {}
func (UnimplementedFooVoServiceServer) testEmbeddedByValue()                      {}

// UnsafeFooVoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooVoServiceServer will
// result in compilation errors.
type UnsafeFooVoServiceServer interface {
	mustEmbedUnimplementedFooVoServiceServer()
}

func RegisterFooVoServiceServer(s grpc.ServiceRegistrar, srv FooVoServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooVoServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooVoService_ServiceDesc, srv)
}

func _FooVoService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVoAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVoServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVoService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVoServiceServer).Add(ctx, req.(*FooVoAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVoService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVoGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVoServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVoService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVoServiceServer).Get(ctx, req.(*FooVoGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVoService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVoPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVoServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVoService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVoServiceServer).Patch(ctx, req.(*FooVoPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVoService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVoGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVoServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVoService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVoServiceServer).Erase(ctx, req.(*FooVoGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooVoService_ServiceDesc is the grpc.ServiceDesc for FooVoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooVoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooVoService",
	HandlerType: (*FooVoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooVoService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooVoService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooVoService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooVoService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooVonService_Add_FullMethodName   = "/example.library.FooVonService/Add"
	FooVonService_Get_FullMethodName   = "/example.library.FooVonService/Get"
	FooVonService_Patch_FullMethodName = "/example.library.FooVonService/Patch"
	FooVonService_Erase_FullMethodName = "/example.library.FooVonService/Erase"
)

// FooVonServiceClient is the client API for FooVonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooVonServiceClient interface {
	Add(ctx context.Context, in *FooVonAddRequest, opts ...grpc.CallOption) (*FooVon, error)
	Get(ctx context.Context, in *FooVonGetRequest, opts ...grpc.CallOption) (*FooVon, error)
	Patch(ctx context.Context, in *FooVonPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooVonGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooVonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooVonServiceClient(cc grpc.ClientConnInterface) FooVonServiceClient {
	return &fooVonServiceClient{cc}
}

func (c *fooVonServiceClient) Add(ctx context.Context, in *FooVonAddRequest, opts ...grpc.CallOption) (*FooVon, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooVon)
	err := c.cc.Invoke(ctx, FooVonService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVonServiceClient) Get(ctx context.Context, in *FooVonGetRequest, opts ...grpc.CallOption) (*FooVon, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooVon)
	err := c.cc.Invoke(ctx, FooVonService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVonServiceClient) Patch(ctx context.Context, in *FooVonPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVonService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVonServiceClient) Erase(ctx context.Context, in *FooVonGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVonService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooVonServiceServer is the server API for FooVonService service.
// All implementations must embed UnimplementedFooVonServiceServer
// for forward compatibility.
type FooVonServiceServer interface {
	Add(context.Context, *FooVonAddRequest) (*FooVon, error)
	Get(context.Context, *FooVonGetRequest) (*FooVon, error)
	Patch(context.Context, *FooVonPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooVonGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooVonServiceServer()
}

// UnimplementedFooVonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooVonServiceServer struct{}

func (UnimplementedFooVonServiceServer) Add(context.Context, *FooVonAddRequest) (*FooVon, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooVonServiceServer) Get(context.Context, *FooVonGetRequest) (*FooVon, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooVonServiceServer) Patch(context.Context, *FooVonPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooVonServiceServer) Erase(context.Context, *FooVonGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooVonServiceServer) mustEmbedUnimplementedFooVonServiceServer() {}
func (UnimplementedFooVonServiceServer) testEmbeddedByValue()                       {}

// UnsafeFooVonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooVonServiceServer will
// result in compilation errors.
type UnsafeFooVonServiceServer interface {
	mustEmbedUnimplementedFooVonServiceServer()
}

func RegisterFooVonServiceServer(s grpc.ServiceRegistrar, srv FooVonServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooVonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooVonService_ServiceDesc, srv)
}

func _FooVonService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVonAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVonServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVonService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVonServiceServer).Add(ctx, req.(*FooVonAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVonService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVonGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVonServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVonService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVonServiceServer).Get(ctx, req.(*FooVonGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVonService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVonPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVonServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVonService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVonServiceServer).Patch(ctx, req.(*FooVonPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVonService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVonGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVonServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVonService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVonServiceServer).Erase(ctx, req.(*FooVonGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooVonService_ServiceDesc is the grpc.ServiceDesc for FooVonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooVonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooVonService",
	HandlerType: (*FooVonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooVonService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooVonService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooVonService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooVonService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}

const (
	FooVrService_Add_FullMethodName   = "/example.library.FooVrService/Add"
	FooVrService_Get_FullMethodName   = "/example.library.FooVrService/Get"
	FooVrService_Patch_FullMethodName = "/example.library.FooVrService/Patch"
	FooVrService_Erase_FullMethodName = "/example.library.FooVrService/Erase"
)

// FooVrServiceClient is the client API for FooVrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FooVrServiceClient interface {
	Add(ctx context.Context, in *FooVrAddRequest, opts ...grpc.CallOption) (*FooVr, error)
	Get(ctx context.Context, in *FooVrGetRequest, opts ...grpc.CallOption) (*FooVr, error)
	Patch(ctx context.Context, in *FooVrPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Erase(ctx context.Context, in *FooVrGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type fooVrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFooVrServiceClient(cc grpc.ClientConnInterface) FooVrServiceClient {
	return &fooVrServiceClient{cc}
}

func (c *fooVrServiceClient) Add(ctx context.Context, in *FooVrAddRequest, opts ...grpc.CallOption) (*FooVr, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooVr)
	err := c.cc.Invoke(ctx, FooVrService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVrServiceClient) Get(ctx context.Context, in *FooVrGetRequest, opts ...grpc.CallOption) (*FooVr, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FooVr)
	err := c.cc.Invoke(ctx, FooVrService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVrServiceClient) Patch(ctx context.Context, in *FooVrPatchRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVrService_Patch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fooVrServiceClient) Erase(ctx context.Context, in *FooVrGetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FooVrService_Erase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FooVrServiceServer is the server API for FooVrService service.
// All implementations must embed UnimplementedFooVrServiceServer
// for forward compatibility.
type FooVrServiceServer interface {
	Add(context.Context, *FooVrAddRequest) (*FooVr, error)
	Get(context.Context, *FooVrGetRequest) (*FooVr, error)
	Patch(context.Context, *FooVrPatchRequest) (*emptypb.Empty, error)
	Erase(context.Context, *FooVrGetRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFooVrServiceServer()
}

// UnimplementedFooVrServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFooVrServiceServer struct{}

func (UnimplementedFooVrServiceServer) Add(context.Context, *FooVrAddRequest) (*FooVr, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFooVrServiceServer) Get(context.Context, *FooVrGetRequest) (*FooVr, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFooVrServiceServer) Patch(context.Context, *FooVrPatchRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFooVrServiceServer) Erase(context.Context, *FooVrGetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Erase not implemented")
}
func (UnimplementedFooVrServiceServer) mustEmbedUnimplementedFooVrServiceServer() {}
func (UnimplementedFooVrServiceServer) testEmbeddedByValue()                      {}

// UnsafeFooVrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FooVrServiceServer will
// result in compilation errors.
type UnsafeFooVrServiceServer interface {
	mustEmbedUnimplementedFooVrServiceServer()
}

func RegisterFooVrServiceServer(s grpc.ServiceRegistrar, srv FooVrServiceServer) {
	// If the following call pancis, it indicates UnimplementedFooVrServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FooVrService_ServiceDesc, srv)
}

func _FooVrService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVrAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVrServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVrService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVrServiceServer).Add(ctx, req.(*FooVrAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVrService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVrGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVrServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVrService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVrServiceServer).Get(ctx, req.(*FooVrGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVrService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVrPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVrServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVrService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVrServiceServer).Patch(ctx, req.(*FooVrPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FooVrService_Erase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FooVrGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FooVrServiceServer).Erase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FooVrService_Erase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FooVrServiceServer).Erase(ctx, req.(*FooVrGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FooVrService_ServiceDesc is the grpc.ServiceDesc for FooVrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FooVrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "example.library.FooVrService",
	HandlerType: (*FooVrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FooVrService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FooVrService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FooVrService_Patch_Handler,
		},
		{
			MethodName: "Erase",
			Handler:    _FooVrService_Erase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/library/foo.svc.proto",
}
